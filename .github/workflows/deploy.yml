name: Deploy to Hostinger

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "18"
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Build React app
        run: npm run build

      - name: Install sshpass
        run: |
          sudo apt-get update
          sudo apt-get install -y sshpass

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -p ${{ secrets.HOSTINGER_SSH_PORT }} -H ${{ secrets.HOSTINGER_SSH_HOST }} >> ~/.ssh/known_hosts

      - name: Deploy to Hostinger
        env:
          SSH_USER: ${{ secrets.HOSTINGER_SSH_USER }}
          SSH_HOST: ${{ secrets.HOSTINGER_SSH_HOST }}
          SSH_PORT: ${{ secrets.HOSTINGER_SSH_PORT }}
          SSH_PASSWORD: ${{ secrets.HOSTINGER_SSH_PASSWORD }}
          DEPLOY_PATH: ${{ secrets.HOSTINGER_DEPLOY_PATH }}
        run: |
          # Create temporary directory for upload
          sshpass -p "$SSH_PASSWORD" ssh -p $SSH_PORT -o StrictHostKeyChecking=no $SSH_USER@$SSH_HOST "mkdir -p ~/deploy-temp"

          # Upload build files
          sshpass -p "$SSH_PASSWORD" scp -P $SSH_PORT -o StrictHostKeyChecking=no -r dist/* $SSH_USER@$SSH_HOST:~/deploy-temp/

          # Deploy to production
          sshpass -p "$SSH_PASSWORD" ssh -p $SSH_PORT -o StrictHostKeyChecking=no $SSH_USER@$SSH_HOST bash << EOF
            set -e
            
            # Use domain-specific path if available, otherwise fallback to provided path
            if [ -d ~/domains/nyuritchiconsulting.com/public_html/test ]; then
              DEPLOY_PATH="~/domains/nyuritchiconsulting.com/public_html/test"
            elif [ -d ~/domains/nyuritchiconsulting.com/public_html ]; then
              DEPLOY_PATH="~/domains/nyuritchiconsulting.com/public_html/test"
            else
              DEPLOY_PATH="$DEPLOY_PATH"
            fi
            
            # Expand ~ to full path
            DEPLOY_PATH=\$(eval echo \$DEPLOY_PATH)
            
            # Backup existing files to backup folder in test directory
            if [ -d "\$DEPLOY_PATH" ] && [ "\$(ls -A \$DEPLOY_PATH 2>/dev/null)" ]; then
              BACKUP_DIR="\$(dirname \$DEPLOY_PATH)/backup"
              mkdir -p "\$BACKUP_DIR"
              BACKUP_NAME="backup-\$(date +%Y%m%d-%H%M%S)"
              cp -r "\$DEPLOY_PATH"/* "\$BACKUP_DIR/\$BACKUP_NAME" || true
            fi
            
            # Create deployment directory and copy files
            mkdir -p "\$DEPLOY_PATH"
            cp -r ~/deploy-temp/* "\$DEPLOY_PATH"/
            
            # Set proper permissions
            find "\$DEPLOY_PATH" -type d -exec chmod 755 {} \;
            find "\$DEPLOY_PATH" -type f -exec chmod 644 {} \;
            
            # Cleanup
            rm -rf ~/deploy-temp
            
            echo "Deployment completed successfully to: \$DEPLOY_PATH"
          EOF
